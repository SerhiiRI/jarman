#+TITLE: Expression concept
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="C:/space/org.css"/>

* Intro
  Every N-dimension vector/array calulation system must allow evaluate math expression with [0..N] local language dimension specyficator. Mean it representation all aspect of linier math(mostly 90% needed apstraction, primitive calculation) argument's, covering only changed dimenstion data and muttable global(in scope of expression) variable and immutable konstants(in scope of exrepssion and scope of hole program). 
** Problems
   In this section discusing DSL-related implementation problem and strategies, which depend on problem and influes to end-side(mean: user) GUΙ and API interface. 

*** Scope viewing
    Scope is also simple think wich must limit reference by AGΤ tree to variable and function stack. 
    This concept create some limitation, for naming variables and functions, or changing naming stack model(mean changing for lexical scope).
    #+begin_export src
    S - SCOPE
    For configuration
      v≡3 ∧ v ∈ S(global)
    function scope is 
      f(v≡3) f ∈ S(global)
    After creating local function context:
      let(f(v ≔ 5)) f ∈ S(S(f)∪(S(f(global) ∩ global)))
    #+end_export
*** Declaration new functions
    Nothing to add. Functino must have expression like declaration, which being used for small lambdas and global functions.
*** Railway expression problem
    All calculation must have two state - ~Nothing(?EMPTY_RESULT) | TypeContainer(RESULT)~ . All middle functor evaluation of function must serving finish execution on ~Nothing~ result for every functor to functor change step.
    This also mean that program must service the ~Nothing~ and ~Nothing(RESULT)~ for converting it to output into string swing component.
*** Combinatory logic
    All function must be simple and clear, and may allow to create closures and compositive lambdas on functor level.

* Math Expression
  Example of expression, influed by math expression notation. Ivention by me notation called FEXP(Flow Expression)
  Sum columns in third columns
  #+begin_src shell
    # <global scope variable> = <logic>
    # $<Number> introspection columns
    $3 = $1 + $2
    $3 = Sum($1,$2)
    $3 = Multi(Sum($1,Pow($2,2)),4)
    $3 = $4 = $1 + $2
    # @<Number> introspect rows
    @1$3 = @1$1 + @1$2
    $:name_f_s = $:first_name + @1$:last_name
    # In column formula do the same without destionation argument
    $1 + $2
    # Var definition
    var = Sum(1,2)
    # Function definition
    MyFunc(n,a) = Sum(n,a+2)
    AnonimicFunc = (n,a) Sum(n,a+2)
    # Loops
    MyFunc(n) = For(1..10,(n)Sum(n,1))
    MyFunc(n) = For(1..10,10..1,(n,x)Sum(n,x))
    # Conditions 
    MyVar = Eq(5,2) true>3 false>4 >0
    MyFunc(n) = Random(10) 0>"A" 1..9>"B" >"D"
    # embading conditional operator
    MyFunc(n) = Random(10) 0>"A" 1..9> ((a) Less(a,5) true> "B1" > "B2" ) >"D"
    # Composit functions in this tepe of expression
    MyCompositFunction(n) = Composit(F2,F1)
    MyCompositFunction(n) = F2(F1(n))
    MyCompositFunction(n) = F1(n) | (e) F2(e)
    # what in other language call "multiline" functions
    Procedure(n) = Sum(n,10) | (n) Minus(10,n) | (n) Eq(n,0) true> "YES" false> "NO"
    # How it look in multiline
    Procedure(n) = Sum(n,10) 
		 | (n) Minus(10,n) 
		 | (n) Eq(n,0) true> "YES" 
			       false> "NO"
  #+end_src
** TODO Vector-list logic evaluation.
* SExpression
  Strongly and lispy example of DSL language, more in Lisp-1 way, otherwise clisp more complicated.
  But i mean primitive version of scheme. Not like clojure, mach simplier
  #+begin_src emacs-lisp
    ; Just lisp, with realization of muttable functions
    def,defn,lambda,let,for,mapcar,car,cdr,<arithmetic operations>...
  #+end_src
* Existing DSL

  Find alredy exist parser of simpliest math calculation and upgrade it
* ALEKS DSL 



  
